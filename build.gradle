import org.objectweb.asm.ClassReader
import org.objectweb.asm.tree.AnnotationNode
import org.objectweb.asm.tree.ClassNode

plugins {
	id "fabric-loom"
	id "org.jetbrains.kotlin.jvm"
	id "com.github.johnrengelman.shadow"
}

//noinspection GroovyUnusedAssignment
archivesBaseName = "tarasande"
version = "1.8.7"
group = "net.tarasandedevelopment"

repositories {
	maven {
		url = "https://oss.sonatype.org/content/repositories/snapshots"
	}
	maven {
		url = "https://repo.viaversion.com"
	}
	maven {
		url = "https://jitpack.io"
	}
	mavenCentral()
}

var libs = [
		// Proxy -> https://mvnrepository.com/artifact/io.netty/netty-handler-proxy
		"io.netty:netty-handler-proxy:4.1.82.Final",

		// BungeeCord Chat -> https://mvnrepository.com/artifact/net.md-5/bungeecord-api
		"net.md-5:bungeecord-api:1.16-R0.4",

		// Packet Library -> https://github.com/FlorianMichael/PacketMinecraft
		"com.github.FlorianMichael:PacketMinecraft:main-SNAPSHOT",

		// HAProxy Protocol -> https://mvnrepository.com/artifact/io.netty/netty-codec-haproxy
		"io.netty:netty-codec-haproxy:4.1.82.Final",

		// NoteBot -> https://github.com/RaphiMC/NoteBlockLib
		"com.github.RaphiMC:NoteBlockLib:6f2b0a5c73",

		// Easing Functions -> https://github.com/FlorianMichael/eZEasing
		"com.github.FlorianMichael:eZEasing:main-SNAPSHOT"
]

var viaLibs = [
		"com.viaversion:viaversion:latest.integration",
		"com.viaversion:viabackwards-common:latest.integration",

		"com.github.RejectedVia:ViaProtocolHack:8eedaa7498"
]

loom {
	accessWidenerPath = file("src/main/resources/tarasande.accesswidener")
}

dependencies {
	// Fabric
    minecraft "com.mojang:minecraft:1.19.2"
    mappings "net.fabricmc:yarn:1.19.2+build.28:v2"
    modImplementation "net.fabricmc:fabric-loader:0.14.10"

	// Kotlin
	modImplementation "net.fabricmc:fabric-language-kotlin:1.8.4+kotlin.1.7.20"

	for (final def lib in libs) {
		implementation(lib)
	}

	for (final def via in viaLibs) {
		implementation(via)
	}
}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 17
}

java {
	withSourcesJar()
}

jar {
	from("LICENSE") {
		rename { "${it}_${project.archivesBaseName}"}
	}
}

remapJar {
	dependsOn shadowJar
    //noinspection GrDeprecatedAPIUsage
	input.set(shadowJar.archiveFile)
}

shadowJar {
    archiveClassifier.set("shadow")
    compileJava.options.encoding = "UTF-8"
	exclude "native-binaries/*"

	dependencies {
		for (final def lib in libs) {
			include(dependency(lib))
		}
	}
}

compileKotlin.kotlinOptions.jvmTarget = "17"

tasks.named('build') {
	doLast {
		sourceSets.main.output.classesDirs.forEach {
			fileTree(it).forEach {
				if (it.name.endsWith(".class")) {
					ClassReader classReader = new ClassReader(it.readBytes())
					ClassNode classNode = new ClassNode()
					classReader.accept(classNode, ClassReader.EXPAND_FRAMES)

					if (classNode.name.startsWith("de/florianmichael"))
						return // Not my project
					if (classNode.name.matches("[^*]*\\\$\\d+\$"))
						return
					// Lambdas don't have names duh (yes, even when kotlin adds some garbled bs, we couldn't care less)

					String actualName = classNode.name.split("/").last().split('\\$').last() // packages don't matter

					if (classNode.name.startsWith("net/tarasandedevelopment/tarasande/mixin/mixins")) {
						// Mixins
						if (classNode.invisibleAnnotations == null || classNode.invisibleAnnotations.isEmpty())
							logger.warn("Are you sure that " + classNode.name + " is a Mixin class?")
						else {
							AnnotationNode pseudo = classNode.invisibleAnnotations.find { it.desc == "Lorg/spongepowered/asm/mixin/Pseudo;" }
							AnnotationNode mixin = classNode.invisibleAnnotations.find { it.desc == "Lorg/spongepowered/asm/mixin/Mixin;" }

							if (pseudo != null) {
								int pseudoIndex = classNode.invisibleAnnotations.indexOf(pseudo);
								if (pseudoIndex != 0 || pseudoIndex + 1 != classNode.invisibleAnnotations.indexOf(mixin))
									logger.warn(classNode.name + " should first annotate @Pseudo following with @Mixin")
							}

							List<Object> values = mixin.values
							if (values == null || values.isEmpty()) {
								logger.warn(classNode.name + " has no target?")
								return // We can't process an invalid class
							}

							String firstKey = values.first()

							String targetClass
							if (firstKey == "targets") {
								targetClass = values.get(1).first().replace(".", "/")
							} else if (firstKey == "value") {
								targetClass = values.get(1).first()
								targetClass = targetClass.substring(1, targetClass.length() - 1)
							} else {
								logger.warn(classNode.name + " has the target class not at first key")
								return // This mixin is invalid...
							}

							targetClass = targetClass.split("/").last()

							if (!targetClass.split('\\$').any {
								return actualName.startsWith("Mixin" + it)
							})
								println(classNode.name + " has a invalid name")
						}
						//println("Mapping " + classNode.visibleAnnotations.first().values.first() + " to " + classNode.name)

					} else {
						// General

						if (classNode.superName == "java/lang/Object" || classNode.superName == "java/lang/Enum")
							return // Ignore non-extending classes

//						if (classNode.superName.startsWith("net/tarasandedevelopment/tarasande/value/Value"))
//							return // Ignore values

						String actualSuperName = classNode.superName.split("/").last().split('\\$').last()
						if (!actualName.startsWith(actualSuperName))
							logger.warn(classNode.name + " has wrong naming conventions (Did you mean '" + actualSuperName + actualName.capitalize() + "'?)")
					}
				}
			}
		}
	}
}

tasks.named('build') {
	doLast {
		String mixinsJson = new String(file("src/main/resources/${archivesBaseName}.mixins.json").readBytes())
		sourceSets.main.output.classesDirs.forEach {
			fileTree(it).forEach {
				if (it.absolutePath.contains("net/tarasandedevelopment/tarasande/mixin/mixins")) {
					String actualName = it.absolutePath.split("net/tarasandedevelopment/tarasande/mixin/mixins").last().replace('/', '.')
					actualName = actualName.substring(1, actualName.length() - 6)
					if (!mixinsJson.contains(actualName) && !it.name.contains('$'))
						logger.warn(actualName + " seems to be an unregistered Mixin")
				}
			}
		}
	}
}